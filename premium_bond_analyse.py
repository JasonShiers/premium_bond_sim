#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Dec 18 12:25:09 2022

@author: Jason Shiers

Premium Bond Monte Carlo analysis
---------------------------------
Reads simulation files generated by sim tool and prints and plots
median and quartile data for various holding sizes
"""

import polars as pl
import matplotlib.pyplot as plt
import seaborn as sns


def group_df(df: pl.DataFrame, holding_size: int = 100_000,
             holding_span: int = 1) -> pl.DataFrame:
    """ Groups df into simulation groups according to the holding_span in months
        and filters bonds to the holding_size to produce a dataframe of total
        winnings for each sim_group
    """

    # Calculate number of required groups padding with holding_span-1 for
    # remainder items if holding_span is not a factor of 6_000_000
    num_groups = (6_000_000 + holding_span - 1) // holding_span

    # Build a lazy query filtering on bonds within holding_size and grouping
    # into num_groups to determine the total prizes won in each grouped sim
    q = (
        df.lazy()
        .filter(df['bond'] < holding_size)
        .group_by(pl.col('sim').mod(num_groups).alias('sim_group'))
        .agg(pl.sum('prize').alias('total_won'))
    )
    grouped_df = q.collect()

    # Remove last partial group if total sims is not divisible by holding_span
    if 6_000_000 % holding_span:
        grouped_df = grouped_df.filter(
            pl.col('sim_group').mod(num_groups) != num_groups - 1)
        num_groups -= 1

    # Fill in any gaps created by sims with no prizes
    all_simulations = pl.DataFrame({'sim_group': range(num_groups)},
                                   schema={'sim_group': pl.Int32})

    result_df = all_simulations.join(grouped_df, on='sim_group', how='left')
    result_df = result_df.fill_null(0)

    return result_df


def get_data_holding_sizes(df: pl.DataFrame, holding_span: int = 1
                           ) -> pl.DataFrame:
    """ Calls group_df for a specified list of holding sizes and the provided
        holding_span, then pivots the data into a dataframe of holding size vs
        total_won for each sim_group
    """
    size_values = [500, 1_000, 2_000, 5_000, 10_000, 20_000, 50_000, 100_000]

    data = [[size, group_df(df, size, holding_span)]
            for size in size_values]

    pivoted_data = [
        100*12/holding_span/size*group['total_won'].alias(str(size))
        for size, group in data]

    return pl.DataFrame().with_columns(pivoted_data)


def boxplot_holding_sizes(pivoted_df: pl.DataFrame) -> pl.DataFrame:
    """ Plots and prints statistics for the pivoted_df obtained from
        get_data_holding_sizes
    """
    plt.figure()
    plt.boxplot(pivoted_df, labels=pivoted_df.columns, showfliers=False)
    plt.xlabel("Holding Size (£)")
    plt.ylabel("Median annual return (%)")

    stats = pivoted_df.describe().with_columns(
        [pl.col(col).round(1) for col in pivoted_df.columns])

    with pl.Config(tbl_cols=-1):
        print(stats)

    return stats


def get_data_holding_spans(df: pl.DataFrame, holding_size: int = 10_000
                           ) -> list[pl.Series]:
    """ Calls group_df for a specified list of holding spans and the provided
        holding_size, then pivots the data into a dataframe of holding span vs
        total_won for each sim_group
    """
    span_values = [1, 2, 6, 12, 24, 60, 120, 240, 600]

    data = [[span, group_df(df, holding_size, span)]
            for span in span_values]

    pivoted_data = [
        100*12/holding_size/span*group['total_won'].alias(str(span))
        for span, group in data]

    return pivoted_data


def boxplot_holding_spans(pivoted_data: list[pl.Series]) -> pl.DataFrame:
    """ Plots and prints statistics for the pivoted_df obtained from
        get_data_holding_spans
    """
    plt.figure()
    plt.boxplot(pivoted_data,
                labels=[s.name for s in pivoted_data], showfliers=False)
    plt.xlabel("Holding Span (months)")
    plt.ylabel("Median annual return (%)")

    stats = pl.DataFrame(pivoted_data[0].describe()['statistic']).with_columns(
        [col.describe()['value'].round(2).alias(col.name)
         for col in pivoted_data])

    with pl.Config(tbl_cols=-1):
        print(stats)

    return stats


def grouped_matrix(df: pl.DataFrame) -> pl.DataFrame:
    """ Calls group_df for a specified list of holding sizes and spans,
        then pivots the data into a dataframe of dataframes holding size vs
        holding_span
    """
    size_values = [500, 1_000, 2_000, 5_000, 10_000, 20_000, 50_000, 100_000]
    span_values = [1, 2, 6, 12, 24, 60, 120, 240, 600]

    data = [[size, span, group_df(df, size, span)]
            for size in size_values for span in span_values]

    matrix_df = pl.DataFrame(data, schema=["size", "span", "dataframe"],
                             orient='row')

    return matrix_df


def median_rate_matrix(matrix_df: pl.DataFrame) -> pl.DataFrame:
    """ Calculates median return percentage for the matrix_df obtained from
        grouped_matrix
    """
    median_prizes = [x.describe().filter(
        pl.col('statistic') == '50%')[0, 2] for x in matrix_df['dataframe']]

    # Create a new DataFrame using the median prizes
    rate_df = matrix_df['size', 'span'].with_columns(
        rate=pl.Series(median_prizes)/pl.col('size')/pl.col('span')*12*100)

    return rate_df


def median_rate_heatmap(rate_df: pl.DataFrame) -> plt.Axes:
    """ Plots and prints median returns for the rate_df obtained from
        median_rate_matrix
    """
    plt.figure()
    pivoted_rate_df = rate_df.pivot('size', index='span', values='rate')
    print("Median return (%) for various holding sizes and spans")
    with pl.Config(tbl_cols=-1):
        print(pivoted_rate_df)

    pd_df_piv = pivoted_rate_df.to_pandas().set_index('span').iloc[::-1, :]
    sns.heatmap(pd_df_piv, annot=True, cbar=False)
    plt.xlabel("Holding Size (£)")
    plt.ylabel("Holding Span (months)")
    plt.title("Premium Bond median annual return (%)")

    plt.figure()
    pct_df = rate_df.with_columns(
        (pl.col('rate')/0.044).round(0).cast(pl.Int16))
    pivoted_rate_df = pct_df.pivot('size', index='span', values='rate')
    print("Median return as a percentage of the prize rate")
    with pl.Config(tbl_cols=-1):
        print(pivoted_rate_df)

    pd_df_piv = pivoted_rate_df.to_pandas().set_index('span').iloc[::-1, :]
    sns.heatmap(pd_df_piv, annot=True, cbar=False)
    plt.xlabel("Holding Size (£)")
    plt.ylabel("Holding Span (months)")
    plt.title("Premium Bond return (% prize rate)")


if __name__ == '__main__':
    # Load input data
    df = pl.read_parquet('premium_bond_6M_sim_202408.parquet')

    # Group by prizes won to see distribution
    df_prizes = df.group_by('prize').agg(
        pl.col('prize').len().alias('frequency')).sort('prize').with_columns(
            (pl.col('frequency')*100/len(df)).alias('percent').round(2))

    with pl.Config(tbl_rows=-1):
        print('Prize distribution')
        print(df_prizes)

    # Explore prize rate for various holding sizes over 6 months
    pivoted_df = get_data_holding_sizes(df, holding_span=6)
    print('Return statistics for various holdings over 6 months')
    boxplot_holding_sizes(pivoted_df)
    plt.title("Premium Bond returns over 6 months")

    # Explore prize rate for various holding spans for 10_000 bonds
    pivoted_data = get_data_holding_spans(df, holding_size=10_000)
    print('Return statistics for various holding spans for 10,000 bonds')
    boxplot_holding_spans(pivoted_data)
    plt.title("Premium Bond returns for a £10,000 holding")

    # Calculate median returns for various holding size and span
    matrix_df = grouped_matrix(df)
    rate_df = median_rate_matrix(matrix_df)
    median_rate_heatmap(rate_df)
